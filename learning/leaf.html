<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - geometry - shapes</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
	</style>
	<script src=""></script>
</head>

<body>

	<script src="js/three.min.js"></script>
	<script src="js/stats.js"></script>

	<script>
		var container, stats;

		var camera, scene, renderer;

		var group;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;

		var mouseX = 0;
		var mouseXOnMouseDown = 0;

		var windowHalfX = window.innerWidth / 2;

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			var info = document.createElement('div');
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'Simple procedurally-generated shapes<br/>Drag to spin';
			container.appendChild(info);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xf0f0f0);

			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(0, 150, 500);
			scene.add(camera);

			var light = new THREE.PointLight(0xffffff, 0.8);
			camera.add(light);

			group = new THREE.Group();
			group.position.y = 50;
			scene.add(group);

			var loader = new THREE.TextureLoader();
			var texture = loader.load("textures/UV_Grid_Sm.jpg");

			// it's necessary to apply these settings in order to correctly display the texture on a shape geometry

			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(0.008, 0.008);

			function addShape(shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {

				// flat shape with texture
				// note: default UVs generated by ShapeBufferGeometry are simply the x- and y-coordinates of the vertices

				// var geometry = new THREE.ShapeBufferGeometry(shape);

				// var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
				// 	side: THREE.DoubleSide,
				// 	map: texture
				// }));
				// mesh.position.set(x, y, z - 175);
				// mesh.rotation.set(rx, ry, rz);
				// mesh.scale.set(s, s, s);
				// group.add(mesh);

				// flat shape

				// var geometry = new THREE.ShapeBufferGeometry(shape);

				// var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
				// 	color: color,
				// 	side: THREE.DoubleSide
				// }));
				// mesh.position.set(x, y, z - 125);
				// mesh.rotation.set(rx, ry, rz);
				// mesh.scale.set(s, s, s);
				// group.add(mesh);

				// extruded shape

				var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);

				var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
					color: color
				}));
				mesh.position.set(x, y, z - 75);
				mesh.rotation.set(rx, ry, rz);
				mesh.scale.set(s, s, s);
				group.add(mesh);

				// addLineShape(shape, color, x, y, z, rx, ry, rz, s);

			}

			function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {

				// lines

				shape.autoClose = true;

				var points = shape.getPoints();
				var spacedPoints = shape.getSpacedPoints(50);

				var geometryPoints = new THREE.BufferGeometry().setFromPoints(points);
				var geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints(spacedPoints);

				// solid line

				var line = new THREE.Line(geometryPoints, new THREE.LineBasicMaterial({
					color: color
				}));
				line.position.set(x, y, z - 25);
				line.rotation.set(rx, ry, rz);
				line.scale.set(s, s, s);
				group.add(line);

				// line from equidistance sampled points

				var line = new THREE.Line(geometrySpacedPoints, new THREE.LineBasicMaterial({
					color: color
				}));
				line.position.set(x, y, z + 25);
				line.rotation.set(rx, ry, rz);
				line.scale.set(s, s, s);
				group.add(line);

				// vertices from real points

				var particles = new THREE.Points(geometryPoints, new THREE.PointsMaterial({
					color: color,
					size: 4
				}));
				particles.position.set(x, y, z + 75);
				particles.rotation.set(rx, ry, rz);
				particles.scale.set(s, s, s);
				group.add(particles);

				// equidistance sampled points

				var particles = new THREE.Points(geometrySpacedPoints, new THREE.PointsMaterial({
					color: color,
					size: 4
				}));
				particles.position.set(x, y, z + 125);
				particles.rotation.set(rx, ry, rz);
				particles.scale.set(s, s, s);
				group.add(particles);

			}


			
			var extrudeSettings = {
				depth: 10,
				bevelEnabled: true,
				bevelSegments: 5,
				steps: 1,
				bevelSize: 1,
				bevelThickness: 1
			};

			var ctx = new THREE.Shape();
			ctx.moveTo(20, 80);
			ctx.bezierCurveTo(20, 180, 220, 90, 200, 80);
			// ctx.moveTo(20, 80);
			ctx.bezierCurveTo(220, 70, 20, -20, 20, 80);
			

			// addShape(heartShape, extrudeSettings, 0xf00000, 60, 100, 0, 0, 0, Math.PI, 1);
			addShape(ctx, extrudeSettings, 448134, 120, 250, 0, 0, 0, Math.PI, 1);
			
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			stats = new Stats();
			container.appendChild(stats.dom);

			document.addEventListener('mousedown', onDocumentMouseDown, false);
			document.addEventListener('touchstart', onDocumentTouchStart, false);
			document.addEventListener('touchmove', onDocumentTouchMove, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function onDocumentMouseDown(event) {

			event.preventDefault();

			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mouseup', onDocumentMouseUp, false);
			document.addEventListener('mouseout', onDocumentMouseOut, false);

			mouseXOnMouseDown = event.clientX - windowHalfX;
			targetRotationOnMouseDown = targetRotation;

		}

		function onDocumentMouseMove(event) {

			mouseX = event.clientX - windowHalfX;

			targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;

		}

		function onDocumentMouseUp(event) {

			document.removeEventListener('mousemove', onDocumentMouseMove, false);
			document.removeEventListener('mouseup', onDocumentMouseUp, false);
			document.removeEventListener('mouseout', onDocumentMouseOut, false);

		}

		function onDocumentMouseOut(event) {

			document.removeEventListener('mousemove', onDocumentMouseMove, false);
			document.removeEventListener('mouseup', onDocumentMouseUp, false);
			document.removeEventListener('mouseout', onDocumentMouseOut, false);

		}

		function onDocumentTouchStart(event) {

			if (event.touches.length == 1) {

				event.preventDefault();

				mouseXOnMouseDown = event.touches[0].pageX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

		}

		function onDocumentTouchMove(event) {

			if (event.touches.length == 1) {

				event.preventDefault();

				mouseX = event.touches[0].pageX - windowHalfX;
				targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;

			}

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}

		function render() {

			group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
			renderer.render(scene, camera);

		}
	</script>

</body>

</html>